== Функциональное программирование

=== Phoenix

* https://www.boost.org/libs/phoenix[boost/phoenix/]
* Позволяет писать лямбда-выражения без использования синтаксиса лямбда-функций
* Основано на отложенных объектах
* Всё работает благодаря перегрузке всех операторов заместителя (placeholder)
* Используется функциональные объекты
** `val` для заместителя значения переменной, `ref` -- для ссылки (область захвата лямбда-выражения)
** `arg1` для заместителя аргумента лямбда-выражения (всегда возвращает свой первый аргумент)
* `boost::phoenix::function` нужен для декорации своего функтора
* Макрос `BOOST_PHOENIX_ADAPT_FUNCTION` используется для формирования отложенной лямбды из C-функции
* `boost::phoenix::bind` -- альтернатива предыдущему
* Дополнительный синтаксис
** `if_` для записи условных выражений
** `[ st1, st2, st3 ]` равносильно определению блока кода `{ st1; st2; st3; }`

<<<

[source,cpp]
----
include::example9-1.cpp[]
----

.Output
----
sys::[{outdir}/example9-1]
----

=== Функциональные объекты

* https://www.boost.org/libs/function[boost/function.hpp]
** Функциональный объект для функции, метода класса, функтора, лямбда-выражения
** Эквивалентно `std::function`
* https://www.boost.org/libs/bind[boost/bind.hpp]
** Предоставляет механизм уменьшения аргументов функции
** Эквивалентно `std::bind`
** Используется там, где лямбды будут выглядеть громоздко
* http://www.boost.org/doc/html/ref.html[boost/ref.hpp]
** Служит для передачи параметров по ссылке в `std::bind`
** У `boost::ref` есть версия с константной ссылкой `boost::cref`
** Эквивалентно `std::ref` и `std::cref`

=== Lambda

* https://www.boost.org/libs/lambda[boost/lambda/]
* Библиотека устарела в связи с появлением `boost::phoenix` и лямбда-выражений в C++11

[source,cpp]
----
include::example9-2.cpp[]
----

.Output
----
sys::[{outdir}/example9-2]
----
