== Библиотеки для работы с приложением

=== Логирование

* https://www.boost.org/libs/log[boost/log/]
* Логгер -- синглтон
* Поддержка мультипоточности (несколько писателей)
* Поддержка ротации логов
* Поддержка нескольких уровней логирования
* Есть некоторые встроенные атрибуты и форматеры. Можно писать свои
* Вся настройка ведётся через функцию, которая вызывается первой в `main`
* Активно используются `boost::parameters` и `boost::fusion`
* Процесс логирования напоминает запись сообщений в поток

<<<

[source,cpp]
----
include::example15-1.cpp[]
----

<1> Паттерн имени лога
<2> Условие размера лога при ротации
<3> Возможна также ротация по времени, например, в полночь
<4> Формат сообщений, которые будем видеть в логах
<5> Включение общих атрибутов, например, `%TimeStamp%`

.Output
----
$ ./example15-1
sys::[{outdir}/example15-1]
$ cat ./sample_0.log
include::{outdir}/sample_0.log[]
----

=== Аргументы командной строки

* https://www.boost.org/libs/program_options[boost/program_options.hpp]
* Опции командной строки
** Позиционные (`git remote prune origin`)
** Непозиционные
*** С аргументом, который отделяется пробелом или `=`
*** С аргументами (зависит от самой команды)
*** Без аргументов
*** Длинные команды с двойным дефисом `--`, команда пишется полностью, в BSD используется один дефис
*** Короткие с одинарным дефисом, от команды остаётся одна буква (обычно первая), пробел перед аргументом можно не писать
*** Команды со слешем
* Представляет опции командной строки в виде ассоциативного массива
* Поддерживаются значения по умолчанию для аргументов
** `--has-default positional options here` => `--has-default -- positional options here`
* Возможность считывать флаги из файла
* Некоторая громоздкость при создании `variables_map`, стоит взглянуть на https://github.com/jarro2783/cxxopts[]
* В случае провала генерируется исключение `boost::program_options::error`
* С помощью `parse_environment()` и `environment_iterator` можно загружать опции через переменные окружения

<<<

[source,cpp]
----
include::example15-2.cpp[]
----

.Output
----
$ ./example15-2 -h
sys::[{outdir}/example15-2 -h]
$ ./example15-2 --age 21
sys::[{outdir}/example15-2 --age 21]
$ ./example15-2 --config <(echo age = 22)
sys::[{outdir}/example15-2 --config example15-2.ini]
----

=== Сериализация

* https://www.boost.org/libs/serialization[boost/serialization/]
* Процесс представления объектов в бинарном виде, который можно сохранить в поток либо восстановить в объект
* В большинстве случаев формат сериализации избыточен
* `boost::archive::text_oarchive` и `boost::archive::text_iarchive` -- простейшие сериализаторы, обёртки над стримами
* Чтобы сериализовать свой класс, необходимо
** Зафрендить класс `boost::serialization::access`
** Реализовать метод `void serialize(Archive& ar, const unsigned int version)`
*** Шаблонный параметр `Archive` -- это сериализатор
*** Считывать/записывать значения в `ar` нужно с помощью оператора `&`
*** Версия привязана к сериализации объекта
** Сериализовать следует требуемые переменные класса
** Сериализация происходит рекурсивно
** Можно реализовать отдельную функцию `void serialize(Archive& ar, MyAwesomeObject& a, const unsigned int version)`

<<<

* Объявление версии объекта делается через макрос `BOOST_CLASS_VERSION(MyAwesomeObject, 42)`
* Умеет работать с умными указателями и создавать объекты в куче
* Сериализация базового класса в наследнике делается через приведение к `boost::serialization::base_object<BaseClass>(*this);`
** Чтобы сериализовать потомок через указатель базового класса, необходимо задекларировать его через `BOOST_CLASS_EXPORT`
* Оптимизаторы для сокращения битового потока сериализованного объекта
** Массивы могут быть оптимизированы с помощью вызова `boost::serialization::make_array(a.data(), a.size())`
** `make_binary_object` используется для сырых данных, например, бинарные данные изображения

<<<

[source,cpp]
----
include::example15-3.cpp[]
----

.Output
----
sys::[{outdir}/example15-3]
----

=== UUID

* https://www.boost.org/libs/uuid[boost/uuid/]
* Universal Unique Identifier в большинстве случаем случайная последовательность чисел стандартизованного формата
* POD тип размера 128 битов
* Не может быть создан напрямую, только через генератор
** `nil_generator` производит нулевой UUID `00000000-0000-0000-0000-000000000000`
** `random_generator` полностью случайный UUID
** `string_generator` для генерации UUID из строки по стандарту
** `name_gen` для получения UUID строки
* Доступные методы
** `size` размер, всегда равен 16 байтам
** `is_nil` является ли UUID нулевым
** `variant` и `version` позволяют понять, какой стандарт использовался при генерации UUID
* Метод `to_string` или `boost::lexical_cast<std::string>` позволяет получить UUID в виде строки

<<<

[source,cpp]
----
include::example15-4.cpp[]
----

.Output
----
sys::[{outdir}/example15-4]
----
