= Master programming pass:[<br>] Лекция №7 (Современный C++)
:author: Игорь Шаронов
:date: 2021-10-10
:lang: ru
:numbered:

== Обзор стандартов

=== Возможности языка на примере стандарта C++98

* https://isocpp.org, https://cppreference.com
* STL (1994 г.) -- не является частью языка, но входит в стандарт
* Конструкторы и деструкторы
* Наследование и полиморфизм
* Шаблонные классы
* Шаблонные функции
* Специализации шаблонов и перегрузка функций
* Константность объектов, методов, выражений (`constexpr`)
* Пространства имён
* Исключения
* Строже типизирован, чем язык C

=== Инкапсуляция, наследование, полиморфизм

* Инкапсуляция позволяет прятать сущности:
** Агрегированные объекты
** Наследование -- способ реализации интерфейсов
* Наследование -- компилятор по типу класса определяет таблицу функций
* Наследование в полиморфизме:
** Справедливо только для указателей или ссылок на базовый класс
** Работает в рантайме
** Компилятор не может по типу указателя базового класса определить тип объекта
** Каждый объект содержит указатель на таблицу функций (методов)
*** Таблицы функций используются одни и те же для одинаковых типов

=== Перегрузка

* Перегрузка функций возможна только в сигнатуре
** Возвращаемое значение не входим в сигнатуру (в C++)
* Специализация класса -- это тоже вид перегрузки
* Частичная специализация класса
** Частичной специализации функций не бывает (не отличимо от обычной перегрузки)
* Можно делать только специализации
** Более общий шаблонный класс останется пустым
** Сигнализация об ошибке будет только в том случае, если не подойдёт ни одна специализация

=== SFINAE

* http://en.cppreference.com/w/cpp/language/sfinae[Substitution Failure Is Not A Error]
* Если вывод специализации приводит к ошибке, то
** данная специализация отбрасывается
** переходим к следующей специализации

[source,cpp]
----
include::sfinae.cpp[]
----

.Output
----
sys::[{outdir}/sfinae]
----

=== Шаблоны

* Уровень компиляции
* `template<class T> int func()`, где `T` -- шаблонный параметр
* `func<int>()`, где `int` -- аргумент шаблона
* Параметр шаблона может быть не-типовым (`int`, `char`, `short`, ...)
** `template<size_t N> int get()`
** Исключения: это не указатель и не тип `double` или `float`
* Специализация функции -- `template<> int func<float>()`

== Обзор стандарта C++03

=== Нововведения

* Развивается библиотека Boost
* Technical Report
* Больше особо нечем гордиться

== Обзор стандарта C++11

=== Новые возможности языка

* Ключевое слово `auto`
** `int k;` == `decltype(k) v;`
* Возвращаемое значение может быть написано после имени функции `auto func(char x) -> int;`
* Появление неименнованных функций (лямбда-выражения)
** `auto f = [](int x) -> double { return std::pow(x, 1.35); };`
** `[a, &b, =, &]` -- замыкание области видимости: по значению, по ссылке, замыкания всей области видимости
* `constexpr` -- функция выполнения на уровне компиляции `int n[func(79)]`
* Универсальная инициализация через `{}`
** `myclass s(7, 9, 8)` и `myclass s{7, 9, 8}` -- одно и то же
** теперь структуры без конструктора и с конструктором могут быть проинициализированы одинаково
* xvalue, rvalue, prvalue -- move-нотации
* Цикл по коллекции `for (const auto& x : array) { ... }`

=== Новые возможности языка (продолжение)

* `override`, `final` -- помогает отлавливать неправильные переопределения в полиморфизме
* `noexcept` -- постепенный отказ от перечисления исключений в сигнатуре
* `nullptr` вместо `NULL` и введение `nullptr_t`
* `enum class` (всё ещё нет автоматического преобразования в строку)
* `static_assert` -- ассерт на уровне компиляции
* `alignas(T)` -- выравнивание данных как у `T`
* **Вариативные шаблоны**

=== Расширение STL

* `std::tuple`, `std::array`, `std::unordered_map/set`, `std::chrono`
* `std::thread`, `std::mutex`, `std::conditional_variable`, `std::atomic` и `thread_local`
* Методы `emplace`
* `std::shared_ptr`, `std::weak_ptr`, `std::unique_ptr`
* `std::function`
* `std::future`, `std::promise`
* `std::hash`
* `std::type_index`
* ...

== Обзор стандарта C++14

=== Новые возможности языка

* Автоматический вывод возвращаемого значения `auto func();`
* `decltype(auto)` -- там, где `auto` отбрасывает слишком много
* Шаблонные переменные `template<class T> T xxx = T(2.78962161L);`
* Агрегатная инициализация
+
[source,cpp]
----
struct abc
{
    int x = 47;
    bool f = true;
    std::string s = "abc";
};
----
* Литералы двоичных чисел и разделители разрядов `0b10110`, `100'500`
* Обобщённые лямбда-выражения `[](auto x) { return x*x + 1; }`
* Атрибут `[[deprecated]]`

=== Нововведения в STL

* Пользовательские литералы `auto dur = 60s;`
* `std::cbegin/std::cend`
* `std::make_index_sequence` для `std::integral_constant` полезен при разворачивании кортежа в аргументы

== Обзор стандарта C++17

=== Новые возможности языка

* Упакованные выражения `template<class... Ts> bool foo(Ts... args) { return (args && ...); }`
* Инициализация переменной в `if` и `switch`: `if (auto a = getA(); a.isValid()) ...`
* Автоматический вывод аргументов шаблона класса `std::vector v{{7, 8, 9}}`
* Structured binding declarations `const auto& [x, y] = mystruct_object;`
* `[[fallthrough]]`, `[[nodiscard]]`, `[[maybe_unused]]`
* Вложенные пространства имён `namespace A::B {}` == `namespace A { namespace B {} }`
* `if constexpr` взамен `std::enable_if` и SFINAE

=== Нововведения в STL

* `std::optional`, `std::variant`, `std::any`
* Поддержка параллельных алгоритмов
* Символьные литералы для UTF-8 `u8`, `u`, `U`
* `std::filesystem`
* `std::string_view`
* `hardware_constructive_interference_size` и `hardware_destructive_interference_size` -- влияние аппаратного кеша
* `std::byte`

== Обзор современных особенностей языка C++

=== О using директиве

* Алиас типа: `using type_int = int;`
* Шаблонные алиас типа: `template<class T> using my_vector = std::vector<T>;`
* Расширение области видимости:
** пространства имён `using namespace std;`
** методов базового класса `using Base::method1;`
*** попадают все сигнатуры `method1`
** конструкторов `using Base::Base`
** если класс шаблонный, необходимо указать имя самого класса `using Derived::Base::Base;`
** наследуются все конструкторы из `Base`, кроме автогенерируемых конструкторов `Base`
* Проблема пересечения имён

=== О rvalue

* Copy elision
+
[source,cpp]
----
T f() { return T(); }
T x = f(); // конструктор копирования не будет вызван
----
* Типы ссылок
+
[cols="2a,1a",grid="none",frame="none"]
|====
|
* lvalue -- обычная ссылка `&` или то, что **имеет имя**
* rvalue -- `&&`, используется чтобы "переместить" содержимое объекта
* prvalue -- результат выражения или то, что **не имеет имени** (42, например)
* xvalue -- временный объект, который имеет имя, но является rvalue
* glvalue -- обобщение xvalue и lvalue

|
[dot]
----
include::images/ref.dot[]
----
|====
* Perfect forwarding и https://habr.com/post/242639[универсальная ссылка]
+
[source,cpp]
----
template<class... Args> void func(Args&&... args) {
    some_func(std::forward<Args>(args)...);
}

std::vector v = {7, 8, 56, 98, 5, 0, -1, 8};
func(v); // [Args = {std::vector<int>&}], & && == &
func(std::move(v)); // [Args = {std::vector<int>&&}], && && == &&
func(std::vector{7.0, 8.3, -96.87, 7.1}); // [Args = {std::vector<double>}], () == &&
----

=== О конструкторах

[source,cpp]
----
class A {
public:
    A(); // default constructor
    A(const A&); // copy constructor
    A(A&&); // move constructor
    A& operator=(const A&); // copy assignment
    A& operator=(A&&); // move assignment
    ~A(); // destructor
}
----

* Порождающие операторы: конструкторы, присваивания, деструктор
* Деструктор почти всегда генерируется сам, его перегрузка ни на что не влияет
* Перегрузка move-конструктора или move-присваивания затрагивает все операции
* Перегрузка конструктора копирования или присваивания не затрагивает move-операции
* `= delete` -- явное удаление порождающего оператора
* `= default` -- попросить компилятор сгенерировать порождающий оператор
* Явное правило вывода конструктора: `template<class T> myclass(T&&, int) -> myclass<T>;`

=== О шаблонах

* `template<class... Ts> class myclass;` -- пакет шаблонных параметров
* `template<class T> constexpr T pi = T(3.1415926535897932385L);` -- шаблонная переменная
* `size_t N = sizeof...(Ts);`
* Хранение аргументов в кортеже
+
[source,cpp]
----
template<class... Ts>
struct abc {
    abc(Ts... ts): x(ts...) {}

    std::tuple<Ts...> x;
}
----

=== Распаковка кортежа в аргументы

* Использование `std::integer_sequence`

[source,cpp]
----
include::example.cpp[]
----

.Output
----
sys::[{outdir}/example]
----

=== Операции над шаблонными пакетами

[source,cpp]
----
template <typename... bases>
struct X : bases... {
    using X::bases::g...;
};
X<B, D> x;
----

Свёртки (наличие скобок важно)

* `( pack op ... )` -- свёртка слева
* `( pack op ... op init )` -- свёртка слева с начальным значением
* `( ... op pack )` -- свёртка справа
* `( init op ... op pack )` -- свёртка справа с начальным значением

[source,cpp]
----
template<typename T, typename... Args>
void push_back_vec(std::vector<T>& v, Args&&... args)
{
    (v.push_back(std::forward<Args>(args)), ...);
}
----

=== О лямбда-выражениях

`auto f = [a = 77, &b](auto x) mutable -> int { b = x - 78; return a++; }`

* Лямбда-выражения == функторы
+
[source,cpp]
----
struct functor
{
    functor(int& b): a_(77), b_(b) {}
    int operator()(int x) const
    {
        b_ = x - 78;
        return a_++;
    }

private:
    mutable int a_;
    int& const b_;
} f;
----
* Невозможно узнать тип лямбда-выражений, т.е. `decltype(lambda) s = ...` не работает
* Чтобы лямбды были полностью объектами, надо заворачивать их в объект `std::function`
* Результат лямбды можно не писать, он будет выведен сам (кроме ссылок)

== Следующие стандарты

=== Концепты и ограничители

[source,cpp]
----
// концепт: как описывать
template<typename T>
concept EqualityComparable = requires(T a, T b)
{
    { a == b } -> bool;
};

// ограничитель: как применять
template<EqualityComparable T> void f(T&&);

// или так применять
template<class T> requires EqualityComparable<T> void f(T&&);
----

* Компактнее вывод об ошибке (с концептами -- 2 строки, без них -- 50+)
* По сигнатуре можно понять, какой тип данных ожидает функция
* Ещё один способ ужесточения типизации

=== Новое в STL

* `std::bit_cast` -- замена `reinterpret_cast`
* Стандартные концепты (Integral, Assignable, Constructible, ...)
* Шаблонный тип может быть классом `template<X x> void func()` (есть ограничения, например, `operator<=>`)
* `operator<=>` -- один оператор покрывает все отношения порядка и равенства (spaceship)
* Все новые особенности языка можно проверить с помощью препроцессорных констант
** например, `__cpp_lib_byte` говорит о наличии `std::byte`
* `std::span` -- декоратор над непрерывной областью памяти
* Ranges -- поддержка концепции диапазонов из `boost::range`
* `std::is_detected` -- детектирование наличия метода/оператора класса
