== Поведенческие паттерны

=== Общие сведения

Определяют взаимодействие классов

=== Chain of responsibility (цепочка обязанностей)

[cols="^a,2a",frame="none",grid="none"]
|===
|
[uml]
----
\include::images/chain_of_responsibility.uml[]
----

|
* Каждый в цепочке либо обрабатывает запрос, либо передаёт дальше
* В случае обработки запроса цепочка может быть либо прервана, либо продолжена
* Реализация "луковицей"
* Возможна реализация через брокера и пайплайн (компоновщик)
* `EndProcessor` может потерять запрос
|===

.Пример
Общение с техподдержкой

=== Command (команда)

[cols="^a,2a",frame="none",grid="none"]
|===
|
[uml]
----
\include::images/command.uml[]
----

|
* Отложенный вызов
* Лямбда-функции
|===

.Пример
Транзакции в базе данных, `std::bind`

=== Iterator (итератор)

[cols="^a,2a",frame="none",grid="none"]
|===
|
[uml]
----
\include::images/iterator.uml[]
----

|
* Придаёт объекту свойства контейнера
* Похож на композицию, может использоваться в цепочке обязанностей
* Могущество спрятано в операторах `++`, `*` и `=`
* Разные способы обхода одного и того же множества
|===

.Пример
`std::vector::iterator`, обход графа в ширину и глубину -- два типа итератора

=== Mediator (посредник)

[cols="^a,2a",frame="none",grid="none"]
|===
|
[uml]
----
\include::images/mediator.uml[]
----

|
* `Main` содержит всю бизнес-логику
* Компоненты общаются между собой только через посредника
* Все компоненты могут использоваться повторно в других программах, но сам посредник не может
* Проблема "божественного объекта"
|===

.Пример
Диспетчерская, диалоговое окно с компонентами

=== Memento (снимок)

[cols="^a,2a",frame="none",grid="none"]
|===
|
[uml]
----
\include::images/memento.uml[]
----

|
* Схож с прототипом
* Не нарушает инкапсуляцию
|===

.Пример
Сериализация

=== Observer (наблюдатель)

[cols="^a,2a",frame="none",grid="none"]
|===
|
[uml]
----
\include::images/observer.uml[]
----

|
* Наблюдатели подписываются на события, генерируемые `Publisher`
* Оповещения происходят в случайном порядке, в отличие от цепочки обязанностей
* Похож на посредника, но `Publisher` ничего не знает о подписчиках
|===

.Пример
Почтовая рассылка

=== State (состояние)

[cols="^a,2a",frame="none",grid="none"]
|===
|
[uml]
----
\include::images/state.uml[]
----

|
* Замена большого switch-case
* `Context` агрегирует объекты `State`
* Каждый `State` может переключать состояние в `Context`
* `State`-ы кое-что знают друг о друге
|===

.Пример
TCP-соединение, переключение окон на экране смартфона

=== Strategy (стратегия)

[cols="^a,2a",frame="none",grid="none"]
|===
|
[uml]
----
\include::images/strategy.uml[]
----

|
* Все стратегии делают одно и то же разными способами
* `Context` схож с мостом и немного адаптером
* Пользователь выбирает стратегии, `Context` их только использует
|===

.Пример
Построение маршрута из точки A в точку B для разных средств передвижения

=== Template method (шаблонный метод)

[cols="^a,2a",frame="none",grid="none"]
|===
|
[uml]
----
\include::images/template_method.uml[]
----

|
* Множественное наследование
* Алгоритм разбивается на шаги, которые реализованы отдельно
* Все шаги комбинируются и жёстко прописаны в `templateMethod`
* `templateMethod` не переопределяется
* Схож со стратегиями, где композиция заменена наследованием
* Невозможно переопределять шаги во время исполнения
|===

.Пример
Общий ИИ для разных персонажей игры

=== Visitor (посетитель)

[cols="^a,2a",frame="none",grid="none"]
|===
|
[uml]
----
\include::images/visitor.uml[]
----

|
* Обход всех компонентов рекурсивно
* Совмещает работу компоновщика и итератор
* Сколько объектов `Objects`, столько должно быть функций `visit` в интерфейсе `Visitor`
* Каждый `Visitor` нужен для реализации какой-то части логики
|===

.Пример
Рекурсивная сериализация в разные форматы (каждый формат -- это новый объект `Visitor`)
