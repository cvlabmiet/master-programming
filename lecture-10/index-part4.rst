Поведенческие паттерны
======================

Общие сведения
--------------

Определяют взаимодействие классов

Chain of responsibility (цепочка обязанностей)
----------------------------------------------

.. class:: column50

    .. image:: chain_of_responsibility.uml.svg

.. class:: column50

    * Каждый в цепочке либо обрабатывает запрос, либо передаёт дальше
    * В случае обработки запроса цепочка может быть либо прервана, либо продолжена
    * Реализация "луковицей"
    * Возможна реализация через брокера и пайплайн (компоновщик)
    * ``EndProcessor`` может потерять запрос

Пример: общение с техподдержкой

Command (команда)
-----------------

.. class:: column50

    .. image:: command.uml.svg

.. class:: column50

    * Отложенный вызов
    * Лямбда-функции

Пример: транзакции в базе данных, ``std::bind``

Iterator (итератор)
-------------------

.. class:: column50

    .. image:: iterator.uml.svg

.. class:: column50

    * Придаёт объекту свойства контейнера
    * Похож на композицию, может использоваться в цепочке обязанностей
    * Могущество спрятано в операторах ``++``, ``*`` и ``=``
    * Разные способы обхода одного и того же множества

Пример: ``std::vector::iterator``, обход графа в ширину и глубину --- два типа итератора

Mediator (посредник)
--------------------

.. class:: column50

    .. image:: mediator.uml.svg

.. class:: column50

    * ``Main`` содержит всю бизнес-логику
    * Компоненты общаются между собой только через посредника
    * Все компоненты могут использоваться повторно в других программах, но сам посредник не может
    * Проблема "божественного объекта"

Пример: диспетчерская, диалоговое окно с компонентами

Memento (снимок)
----------------

.. class:: column50

    .. image:: memento.uml.svg

.. class:: column50

    * Схож с прототипом
    * Не нарушает инкапсуляцию

Пример: сериализация

Observer (наблюдатель)
----------------------

.. class:: column50

    .. image:: observer.uml.svg

.. class:: column50

    * Наблюдатели подписываются на события, генерируемые ``Publisher``
    * Оповещения происходят в случайном порядке, в отличие от цепочки обязанностей
    * Похож на посредника, но ``Publisher`` ничего не знает о подписчиках

Пример: почтовая рассылка

State (состояние)
-----------------

.. class:: column50

    .. image:: state.uml.svg

.. class:: column50

    * Замена большого switch-case
    * ``Context`` агрегирует объекты ``State``
    * Каждый ``State`` может переключать состояние в ``Context``
    * ``State``-ы кое-что знают друг о друге

Пример: TCP-соединение, переключение окон на экране смартфона

Strategy (стратегия)
--------------------

.. class:: column50

    .. image:: strategy.uml.svg

.. class:: column50

    * Все стратегии делают одно и то же разными способами
    * ``Context`` схож с мостом и немного адаптером
    * Пользователь выбирает стратегии, ``Context`` их только использует

Пример: построение маршрута из точки A в точку B для разных средств передвижения

Template method (шаблонный метод)
---------------------------------

.. class:: column33

    .. image:: template_method.uml.svg

.. class:: column66

    * Множественное наследование
    * Алгоритм разбивается на шаги, которые реализованы отдельно
    * Все шаги комбинируются и жёстко прописаны в ``templateMethod``
    * ``templateMethod`` не переопределяется
    * Схож со стратегиями, где композиция заменена наследованием
    * Невозможно переопределять шаги во время исполнения

Пример: общий ИИ для разных персонажей игры

Visitor (посетитель)
--------------------

.. class:: column50

    .. image:: visitor.uml.svg

.. class:: column50

    * Обход всех компонентов рекурсивно
    * Совмещает работу компоновщика и итератор
    * Сколько объектов ``Objects``, столько должно быть функций ``visit`` в интерфейсе ``Visitor``
    * Каждый ``Visitor`` нужен для реализации какой-то части логики

Пример: рекурсивная сериализация в разные форматы (каждый формат --- это новый объект ``Visitor``)
