<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru-RU" xml:lang="ru-RU">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Игорь Шаронов" />
  <meta name="date" content="2018-10-03" />
  <title>Master Programming</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print" href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" data-external="1" />
  <style type="text/css">
      .reveal h1 { font-size: 2em; }
      .reveal h2 { font-size: 2em; }
      .reveal h3 { font-size: 1em; }
      .reveal pre code { max-height: 600px; }
      div.column33 {display: inline-block; vertical-align: top; width: 32%;}
      div.column66 {display: inline-block; vertical-align: top; width: 66%;}
      div.column50 {display: inline-block; vertical-align: top; width: 45%;}
      .strike {text-decoration: line-through;}
      table, th, td {
          border: 1px solid black;
      }
  </style>
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js" charset="utf-8" type="text/javascript" data-external="1"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Master programming</h1>
  <p class="subtitle">Лекция №7 (Современный C++)</p>
  <p class="author">
Игорь Шаронов
  </p>
  <p class="date">2018-10-03</p>
</div>
<div id="обзор-стандартов" class="title-slide slide section level1">
<h1>Обзор стандартов</h1>

</div>
<div id="возможности-языка-на-примере-стандарта-c98" class="slide section level2">
<h1>Возможности языка на примере стандарта C++98</h1>
<ul>
<li><a href="https://isocpp.org">https://isocpp.org</a>, <a href="https://cppreference.com">https://cppreference.com</a></li>
<li>STL (1994 г.)— не является частью языка, но входит в стандарт</li>
<li>Конструкторы и деструкторы</li>
<li>Наследование и полиморфизм</li>
<li>Шаблонные классы</li>
<li>Шаблонные функции</li>
<li>Специализации шаблонов и перегрузка функций</li>
<li>Константность объектов, методов, выражений (<code class="sourceCode cpp"><span class="kw">constexpr</span></code>)</li>
<li>Пространства имён</li>
<li>Исключения</li>
<li>Строже типизирован, чем язык C</li>
</ul>
</div>
<div id="инкапсуляция-наследование-полиморфизм" class="slide section level2">
<h1>Инкапсуляция, наследование, полиморфизм</h1>
<ul>
<li>Инкапсуляция позволяет прятать сущности:
<ul>
<li>Агрегированные объекты</li>
<li>Наследование — способ реализации интерфейсов</li>
</ul></li>
<li>Наследование — компилятор по типу класса определяет таблицу функций</li>
<li>Наследование в полиморфизме:
<ul>
<li>Справедливо только для указателей или ссылок на базовый класс</li>
<li>Работает в рантайме</li>
<li>Компилятор не может по типу указателя базового класса определить тип объекта</li>
<li>Каждый объект содержит указатель на таблицу функций (методов)
<ul>
<li>Таблицы функций используются одни и те же для одинаковых типов</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="перегрузка" class="slide section level2">
<h1>Перегрузка</h1>
<ul>
<li>Перегрузка функций возможна только в сигнатуре
<ul>
<li>Возвращаемое значение не входим в сигнатуру (в C++)</li>
</ul></li>
<li>Специализация класса — это тоже вид перегрузки</li>
<li>Частичная специализация класса
<ul>
<li>Частичной специализации функций не бывает (не отличимо от обычной перегрузки)</li>
</ul></li>
<li>Можно делать только специализации
<ul>
<li>Более общий шаблонный класс останется пустым</li>
<li>Сигнализация об ошибке будет только в том случае, если не подойдёт ни одна специализация</li>
</ul></li>
</ul>
</div>
<div id="sfinae" class="slide section level2">
<h1>SFINAE</h1>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/language/sfinae">Substitution Failure Is Not A Error</a></li>
<li>Если вывод специализации приводит к ошибке, то
<ul>
<li>данная специализация отбрасывается</li>
<li>переходим к следующей специализации</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="dt">int</span> f<span class="op">(</span><span class="kw">typename</span> T<span class="op">::</span>B<span class="op">*);</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="dt">int</span> f<span class="op">(</span>T<span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> f<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">0</span><span class="op">);</span> <span class="co">// uses second overload</span></span></code></pre></div>
</div>
<div id="шаблоны" class="slide section level2">
<h1>Шаблоны</h1>
<ul>
<li>Уровень компиляции</li>
<li><code class="sourceCode cpp"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="dt">int</span> func<span class="op">()</span></code>, где <code>T</code> — шаблонный параметр</li>
<li><code class="sourceCode cpp">func<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;()</span></code>, где <code class="sourceCode cpp"><span class="dt">int</span></code> — аргумент шаблона</li>
<li>Параметр шаблона может быть не-типовым (int, char, short, …)
<ul>
<li><code class="sourceCode cpp"><span class="kw">template</span><span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span> <span class="dt">int</span> get<span class="op">()</span></code></li>
<li>Исключения: это не указатель и не тип <code class="sourceCode cpp"><span class="dt">double</span></code> или <code class="sourceCode cpp"><span class="dt">float</span></code></li>
</ul></li>
<li>Специализация функции — <code class="sourceCode cpp"><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="dt">int</span> func<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;()</span></code></li>
</ul>
</div>

<div id="обзор-стандарта-c03" class="title-slide slide section level1">
<h1>Обзор стандарта C++03</h1>

</div>
<div id="нововведения" class="slide section level2">
<h1>Нововведения</h1>
<ul>
<li>Развивается библиотека Boost</li>
<li>Technical Report</li>
<li>Больше особо нечем гордиться</li>
</ul>
</div>

<div id="обзор-стандарта-c11" class="title-slide slide section level1">
<h1>Обзор стандарта C++11</h1>

</div>
<div id="новые-возможности-языка" class="slide section level2">
<h1>Новые возможности языка</h1>
<ul>
<li>Ключевое слово <code class="sourceCode cpp"><span class="kw">auto</span></code>
<ul>
<li><code class="sourceCode cpp"><span class="dt">int</span> k<span class="op">;</span></code> == <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">(</span>k<span class="op">)</span> v<span class="op">;</span></code></li>
</ul></li>
<li>Возвращаемое значение может быть написано после имени функции <code class="sourceCode cpp"><span class="kw">auto</span> func<span class="op">(</span><span class="dt">char</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span><span class="op">;</span></code></li>
<li>Появление неименнованных функций (лямбда-выражения)
<ul>
<li><code class="sourceCode cpp"><span class="kw">auto</span> f <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">double</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>pow<span class="op">(</span>x<span class="op">,</span> <span class="fl">1.35</span><span class="op">);</span> <span class="op">};</span></code></li>
<li><code class="sourceCode cpp"><span class="op">[</span>a<span class="op">,</span> <span class="op">&amp;</span>b<span class="op">,</span> <span class="op">=,</span> <span class="op">&amp;]</span></code> — замыкание области видимости: по значению, по ссылке, замыкания всей области видимости</li>
</ul></li>
<li><code class="sourceCode cpp"><span class="kw">constexpr</span></code> — функция выполнения на уровне компиляции <code class="sourceCode cpp"><span class="dt">int</span> n<span class="op">[</span>func<span class="op">(</span><span class="dv">79</span><span class="op">)]</span></code></li>
<li>Универсальная инициализация через <code>{}</code>
<ul>
<li><code class="sourceCode cpp">myclass s<span class="op">(</span><span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">8</span><span class="op">)</span></code> и <code class="sourceCode cpp">myclass s<span class="op">{</span><span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">8</span><span class="op">}</span></code> — одно и то же</li>
<li>теперь структуры без конструктора и с конструктором могут быть проинициализированы одинаково</li>
</ul></li>
<li>xvalue, rvalue, prvalue — move-нотации</li>
<li>Цикл по коллекции <code class="sourceCode cpp"><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> x <span class="op">:</span> array<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></code></li>
</ul>
</div>
<div id="новые-возможности-языка-продолжение" class="slide section level2">
<h1>Новые возможности языка (продолжение)</h1>
<ul>
<li><code class="sourceCode cpp"><span class="kw">override</span></code>, <code class="sourceCode cpp"><span class="kw">final</span></code> — помогает отлавливать неправильные переопределения в полиморфизме</li>
<li><code class="sourceCode cpp"><span class="kw">noexcept</span></code> — постепенный отказ от перечисления исключений в сигнатуре</li>
<li><code class="sourceCode cpp"><span class="kw">nullptr</span></code> вместо <code class="sourceCode cpp">NULL</code> и введение <code class="sourceCode cpp"><span class="dt">nullptr_t</span></code></li>
<li><code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">class</span></code> (всё ещё нет автоматического преобразования в строку)</li>
<li><code class="sourceCode cpp"><span class="kw">static_assert</span></code> — ассерт на уровне компиляции</li>
<li><code class="sourceCode cpp"><span class="kw">alignas</span><span class="op">(</span>T<span class="op">)</span></code> — выравнивание данных как у <code>T</code></li>
<li><strong>Вариативные шаблоны</strong></li>
</ul>
</div>
<div id="расширение-stl" class="slide section level2">
<h1>Расширение STL</h1>
<ul>
<li><code>std::tuple</code>, <code>std::array</code>, <code>std::unordered_map/set</code>, <code>std::chrono</code></li>
<li><code>std::thread</code>, <code>std::mutex</code>, <code>std::conditional_variable</code>, <code>std::atomic</code> и <code>thread_local</code></li>
<li>Методы <code>emplace</code></li>
<li><code>std::shared_ptr</code>, <code>std::weak_ptr</code>, <code>std::unique_ptr</code></li>
<li><code>std::function</code></li>
<li><code>std::future</code>, <code>std::promise</code></li>
<li><code>std::hash</code></li>
<li><code>std::type_index</code></li>
<li>…</li>
</ul>
</div>

<div id="обзор-стандарта-c14" class="title-slide slide section level1">
<h1>Обзор стандарта C++14</h1>

</div>
<div id="новые-возможности-языка-1" class="slide section level2">
<h1>Новые возможности языка</h1>
<ul>
<li><p>Автоматический вывод возвращаемого значения <code class="sourceCode cpp"><span class="kw">auto</span> func<span class="op">();</span></code></p></li>
<li><p><code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span></code> — там, где <code class="sourceCode cpp"><span class="kw">auto</span></code> отбрасывает слишком много</p></li>
<li><p>Шаблонные переменные <code class="sourceCode cpp"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> T xxx <span class="op">=</span> T<span class="op">(</span><span class="fl">2.78962161</span><span class="bu">L</span><span class="op">);</span></code></p></li>
<li><p>Агрегатная инициализация</p>
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> abc</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">47</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> f <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>s <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
</blockquote></li>
<li><p>Литералы двоичных чисел и разделители разрядов <code class="sourceCode cpp"><span class="bn">0b10110</span></code>, <code class="sourceCode cpp"><span class="dv">100&#39;500</span></code></p></li>
<li><p>Обобщённые лямбда-выражения <code class="sourceCode cpp"><span class="op">[](</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">*</span>x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></code></p></li>
<li><p>Атрибут <code class="sourceCode cpp"><span class="op">[[</span><span class="at">deprecated</span><span class="op">]]</span></code></p></li>
</ul>
</div>
<div id="нововведения-в-stl" class="slide section level2">
<h1>Нововведения в STL</h1>
<ul>
<li>Пользовательские литералы <code class="sourceCode cpp"><span class="kw">auto</span> dur <span class="op">=</span> <span class="dv">60</span><span class="bu">s</span><span class="op">;</span></code></li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>cbegin<span class="op">/</span><span class="bu">std::</span>cend</code></li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>make_index_sequence</code> для <code class="sourceCode cpp"><span class="bu">std::</span>integral_constant</code> полезен при разворачивании кортежа в аргументы</li>
</ul>
</div>

<div id="обзор-стандарта-c17" class="title-slide slide section level1">
<h1>Обзор стандарта C++17</h1>

</div>
<div id="новые-возможности-языка-2" class="slide section level2">
<h1>Новые возможности языка</h1>
<ul>
<li>Упакованные выражения <code class="sourceCode cpp"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span> <span class="dt">bool</span> foo<span class="op">(</span>Ts<span class="op">...</span> args<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>args <span class="op">&amp;&amp;</span> <span class="op">...);</span> <span class="op">}</span></code></li>
<li>Инициализация переменной в <code class="sourceCode cpp"><span class="cf">if</span></code> и <code class="sourceCode cpp"><span class="cf">switch</span></code>: <code class="sourceCode cpp"><span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> a <span class="op">=</span> getA<span class="op">();</span> a<span class="op">.</span>isValid<span class="op">())</span> <span class="op">...</span></code></li>
<li>Автоматический вывод аргументов шаблона класса <code class="sourceCode cpp"><span class="bu">std::</span>vector<span class="op"> </span>v<span class="op">{{</span><span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">}}</span></code></li>
<li>Structured binding declarations <code class="sourceCode cpp"><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">]</span> <span class="op">=</span> mystruct_object<span class="op">;</span></code></li>
<li><code class="sourceCode cpp"><span class="op">[[</span><span class="at">fallthrough</span><span class="op">]]</span></code>, <code class="sourceCode cpp"><span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span></code>, <code class="sourceCode cpp"><span class="op">[[</span><span class="at">maybe_unused</span><span class="op">]]</span></code></li>
<li>Вложенные пространства имён <code class="sourceCode cpp"><span class="kw">namespace</span> A<span class="op">::</span>B <span class="op">{}</span></code> == <code class="sourceCode cpp"><span class="kw">namespace</span> A <span class="op">{</span> <span class="kw">namespace</span> B <span class="op">{}</span> <span class="op">}</span></code></li>
<li><code class="sourceCode cpp"><span class="cf">if</span> <span class="kw">constexpr</span></code> взамен <code class="sourceCode cpp"><span class="bu">std::</span>enable_if</code> и SFINAE</li>
</ul>
</div>
<div id="нововведения-в-stl-1" class="slide section level2">
<h1>Нововведения в STL</h1>
<ul>
<li><code class="sourceCode cpp"><span class="bu">std::</span>optional</code>, <code class="sourceCode cpp"><span class="bu">std::</span>variant</code>, <code class="sourceCode cpp"><span class="bu">std::</span>any</code></li>
<li>Поддержка параллельных алгоритмов</li>
<li>Символьные литералы для UTF-8 <code class="sourceCode cpp">u8</code>, <code class="sourceCode cpp">u</code>, <code class="sourceCode cpp">U</code></li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>filesystem</code></li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>string_view</code></li>
<li><code>hardware_constructive_interference_size</code> и <code>hardware_destructive_interference_size</code> — влияние аппаратного кеша</li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>byte</code></li>
</ul>
</div>

<div id="обзор-современных-особенностей-языка-c" class="title-slide slide section level1">
<h1>Обзор современных особенностей языка C++</h1>

</div>
<div id="о-using-директиве" class="slide section level2">
<h1>О using директиве</h1>
<ul>
<li>Алиас типа: <code class="sourceCode cpp"><span class="kw">using</span> type_int <span class="op">=</span> <span class="dt">int</span><span class="op">;</span></code></li>
<li>Шаблонные алиас типа: <code class="sourceCode cpp"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">using</span> my_vector <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;;</span></code></li>
<li>Расширение области видимости:
<ul>
<li>пространства имён <code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></code></li>
<li>методов базового класса <code class="sourceCode cpp"><span class="kw">using</span> Base<span class="op">::</span>method1<span class="op">;</span></code>
<ul>
<li>попадают все сигнатуры <code>method1</code></li>
</ul></li>
<li>конструкторов <code class="sourceCode cpp"><span class="kw">using</span> Base<span class="op">::</span>Base</code>
<ul>
<li>если класс шаблонный, необходимо указать имя самого класса <code class="sourceCode cpp"><span class="kw">using</span> Derived<span class="op">::</span>Base<span class="op">::</span>Base<span class="op">;</span></code></li>
<li>наследуются все конструкторы из <code>Base</code>, кроме автогенерируемых конструкторов <code>Base</code></li>
</ul></li>
</ul></li>
<li>Проблема пересечения имён</li>
</ul>
</div>
<div id="о-rvalue" class="slide section level2">
<h1>О rvalue</h1>
<ul>
<li><p>Copy elision</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>T f<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> T<span class="op">();</span> <span class="op">}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>T x <span class="op">=</span> f<span class="op">();</span> <span class="co">// конструктор копирования не будет вызван</span></span></code></pre></div></li>
<li><p>Типы ссылок</p>
<div class="column66">
<ul>
<li>lvalue — обычная ссылка <code>&amp;</code> или то, что <strong>имеет имя</strong></li>
<li>rvalue — <code>&amp;&amp;</code>, используется чтобы “переместить” содержимое объекта</li>
<li>prvalue — результат выражения или то, что <strong>не имеет имени</strong> (42, например)</li>
<li>xvalue — временный объект, который имеет имя, но являет rvalue</li>
<li>glvalue — обобщение xvalue и lvalue</li>
</ul>
</div>
<div class="column33">
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8IS0tIEdlbmVyYXRlZCBieSBncmFwaHZpeiB2ZXJzaW9uIDIuNDMuMCAoMCkKIC0tPgo8IS0tIFRpdGxlOiBHIFBhZ2VzOiAxIC0tPgo8c3ZnIHdpZHRoPSIyOTBwdCIgaGVpZ2h0PSIxODhwdCIKIHZpZXdCb3g9IjAuMDAgMC4wMCAyODkuNTQgMTg4LjAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KPGcgaWQ9ImdyYXBoMCIgY2xhc3M9ImdyYXBoIiB0cmFuc2Zvcm09InNjYWxlKDEgMSkgcm90YXRlKDApIHRyYW5zbGF0ZSg0IDE4NCkiPgo8dGl0bGU+RzwvdGl0bGU+Cjxwb2x5Z29uIGZpbGw9IndoaXRlIiBzdHJva2U9InRyYW5zcGFyZW50IiBwb2ludHM9Ii00LDQgLTQsLTE4NCAyODUuNTQsLTE4NCAyODUuNTQsNCAtNCw0Ii8+CjwhLS0gZXhwcmVzc2lvbiAtLT4KPGcgaWQ9Im5vZGUxIiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT5leHByZXNzaW9uPC90aXRsZT4KPGVsbGlwc2UgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgY3g9IjEzNS43IiBjeT0iLTE2MiIgcng9IjU5LjU5IiByeT0iMTgiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iMTM1LjciIHk9Ii0xNTguMyIgZm9udC1mYW1pbHk9IlRpbWVzLVJvbWFuIiBmb250LXNpemU9IjE0LjAwIj5leHByZXNzaW9uPC90ZXh0Pgo8L2c+CjwhLS0gZ2x2YWx1ZSAtLT4KPGcgaWQ9Im5vZGUyIiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT5nbHZhbHVlPC90aXRsZT4KPGVsbGlwc2UgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgY3g9Ijg1LjciIGN5PSItOTAiIHJ4PSI0My41OSIgcnk9IjE4Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9Ijg1LjciIHk9Ii04Ni4zIiBmb250LWZhbWlseT0iVGltZXMtUm9tYW4iIGZvbnQtc2l6ZT0iMTQuMDAiPmdsdmFsdWU8L3RleHQ+CjwvZz4KPCEtLSBleHByZXNzaW9uJiM0NTsmZ3Q7Z2x2YWx1ZSAtLT4KPGcgaWQ9ImVkZ2UxIiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT5leHByZXNzaW9uJiM0NTsmZ3Q7Z2x2YWx1ZTwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik0xMjMuNTksLTE0NC4wNUMxMTcuNTcsLTEzNS42MyAxMTAuMTgsLTEyNS4yOCAxMDMuNTMsLTExNS45NyIvPgo8cG9seWdvbiBmaWxsPSJibGFjayIgc3Ryb2tlPSJibGFjayIgcG9pbnRzPSIxMDYuMzUsLTExMy44OSA5Ny42OSwtMTA3Ljc5IDEwMC42NSwtMTE3Ljk2IDEwNi4zNSwtMTEzLjg5Ii8+CjwvZz4KPCEtLSBydmFsdWUgLS0+CjxnIGlkPSJub2RlMyIgY2xhc3M9Im5vZGUiPgo8dGl0bGU+cnZhbHVlPC90aXRsZT4KPGVsbGlwc2UgZmlsbD0iQXF1YW1hcmluZSIgc3Ryb2tlPSJibGFjayIgY3g9IjE4Ni43IiBjeT0iLTkwIiByeD0iMzguOTkiIHJ5PSIxOCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSIxODYuNyIgeT0iLTg2LjMiIGZvbnQtZmFtaWx5PSJUaW1lcy1Sb21hbiIgZm9udC1zaXplPSIxNC4wMCI+cnZhbHVlPC90ZXh0Pgo8L2c+CjwhLS0gZXhwcmVzc2lvbiYjNDU7Jmd0O3J2YWx1ZSAtLT4KPGcgaWQ9ImVkZ2UyIiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT5leHByZXNzaW9uJiM0NTsmZ3Q7cnZhbHVlPC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgZD0iTTE0OC4wNCwtMTQ0LjA1QzE1NC4yNywtMTM1LjUgMTYxLjk0LC0xMjQuOTcgMTY4LjgxLC0xMTUuNTYiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iMTcxLjc2LC0xMTcuNDUgMTc0LjgyLC0xMDcuMzEgMTY2LjEsLTExMy4zMyAxNzEuNzYsLTExNy40NSIvPgo8L2c+CjwhLS0gbHZhbHVlIC0tPgo8ZyBpZD0ibm9kZTQiIGNsYXNzPSJub2RlIj4KPHRpdGxlPmx2YWx1ZTwvdGl0bGU+CjxlbGxpcHNlIGZpbGw9IkFxdWFtYXJpbmUiIHN0cm9rZT0iYmxhY2siIGN4PSIzNy43IiBjeT0iLTE4IiByeD0iMzcuODkiIHJ5PSIxOCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSIzNy43IiB5PSItMTQuMyIgZm9udC1mYW1pbHk9IlRpbWVzLVJvbWFuIiBmb250LXNpemU9IjE0LjAwIj5sdmFsdWU8L3RleHQ+CjwvZz4KPCEtLSBnbHZhbHVlJiM0NTsmZ3Q7bHZhbHVlIC0tPgo8ZyBpZD0iZWRnZTMiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPmdsdmFsdWUmIzQ1OyZndDtsdmFsdWU8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBkPSJNNzQuMzIsLTcyLjQxQzY4LjQ2LC02My44NyA2MS4yLC01My4yOCA1NC42OSwtNDMuNzkiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iNTcuNTMsLTQxLjc0IDQ4Ljk5LC0zNS40NyA1MS43NiwtNDUuNyA1Ny41MywtNDEuNzQiLz4KPC9nPgo8IS0tIHh2YWx1ZSAtLT4KPGcgaWQ9Im5vZGU1IiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT54dmFsdWU8L3RpdGxlPgo8ZWxsaXBzZSBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBjeD0iMTMzLjciIGN5PSItMTgiIHJ4PSI0MC4wOSIgcnk9IjE4Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjEzMy43IiB5PSItMTQuMyIgZm9udC1mYW1pbHk9IlRpbWVzLVJvbWFuIiBmb250LXNpemU9IjE0LjAwIj54dmFsdWU8L3RleHQ+CjwvZz4KPCEtLSBnbHZhbHVlJiM0NTsmZ3Q7eHZhbHVlIC0tPgo8ZyBpZD0iZWRnZTQiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPmdsdmFsdWUmIzQ1OyZndDt4dmFsdWU8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBkPSJNOTcuMDcsLTcyLjQxQzEwMi45MywtNjMuODcgMTEwLjE5LC01My4yOCAxMTYuNywtNDMuNzkiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iMTE5LjYzLC00NS43IDEyMi40LC0zNS40NyAxMTMuODYsLTQxLjc0IDExOS42MywtNDUuNyIvPgo8L2c+CjwhLS0gcnZhbHVlJiM0NTsmZ3Q7eHZhbHVlIC0tPgo8ZyBpZD0iZWRnZTUiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPnJ2YWx1ZSYjNDU7Jmd0O3h2YWx1ZTwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik0xNzQuNCwtNzIuNzZDMTY3Ljg4LC02NC4xNCAxNTkuNzIsLTUzLjM2IDE1Mi40MiwtNDMuNzMiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iMTU1LjEyLC00MS40OSAxNDYuMjksLTM1LjYzIDE0OS41NCwtNDUuNzIgMTU1LjEyLC00MS40OSIvPgo8L2c+CjwhLS0gcHJ2YWx1ZSAtLT4KPGcgaWQ9Im5vZGU2IiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT5wcnZhbHVlPC90aXRsZT4KPGVsbGlwc2UgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgY3g9IjIzNi43IiBjeT0iLTE4IiByeD0iNDQuNjkiIHJ5PSIxOCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSIyMzYuNyIgeT0iLTE0LjMiIGZvbnQtZmFtaWx5PSJUaW1lcy1Sb21hbiIgZm9udC1zaXplPSIxNC4wMCI+cHJ2YWx1ZTwvdGV4dD4KPC9nPgo8IS0tIHJ2YWx1ZSYjNDU7Jmd0O3BydmFsdWUgLS0+CjxnIGlkPSJlZGdlNiIgY2xhc3M9ImVkZ2UiPgo8dGl0bGU+cnZhbHVlJiM0NTsmZ3Q7cHJ2YWx1ZTwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik0xOTguMjksLTcyLjc2QzIwNC4zOSwtNjQuMjMgMjEyLC01My41OCAyMTguODMsLTQ0LjAyIi8+Cjxwb2x5Z29uIGZpbGw9ImJsYWNrIiBzdHJva2U9ImJsYWNrIiBwb2ludHM9IjIyMS44NSwtNDUuODEgMjI0LjgyLC0zNS42MyAyMTYuMTYsLTQxLjc0IDIyMS44NSwtNDUuODEiLz4KPC9nPgo8L2c+Cjwvc3ZnPgo=" alt="image" /></p>
</div></li>
<li><p>Perfect forwarding и <a href="https://habr.com/post/242639">универсальная ссылка</a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Args<span class="op">&gt;</span> <span class="dt">void</span> func<span class="op">(</span>Args<span class="op">&amp;&amp;...</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    some_func<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>Args<span class="op">&gt;(</span>args<span class="op">)...);</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op"> </span>v <span class="op">=</span> <span class="op">{</span><span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">56</span><span class="op">,</span> <span class="dv">98</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">8</span><span class="op">};</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>func<span class="op">(</span>v<span class="op">);</span> <span class="co">// [Args = {std::vector&lt;int&gt;&amp;}], &amp; &amp;&amp; == &amp;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>func<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>v<span class="op">));</span> <span class="co">// [Args = {std::vector&lt;int&gt;&amp;&amp;}], &amp;&amp; &amp;&amp; == &amp;&amp;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>func<span class="op">(</span><span class="bu">std::</span>vector<span class="op">{</span><span class="fl">7.0</span><span class="op">,</span> <span class="fl">8.3</span><span class="op">,</span> <span class="op">-</span><span class="fl">96.87</span><span class="op">,</span> <span class="fl">7.1</span><span class="op">});</span> <span class="co">// [Args = {std::vector&lt;double&gt;}], () == &amp;&amp;</span></span></code></pre></div></li>
</ul>
</div>
<div id="о-конструкторах" class="slide section level2">
<h1>О конструкторах</h1>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">();</span> <span class="co">// default constructor</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="at">const</span> A<span class="op">&amp;);</span> <span class="co">// copy constructor</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span>A<span class="op">&amp;&amp;);</span> <span class="co">// move constructor</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> A<span class="op">&amp;);</span> <span class="co">// copy assignment</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>A<span class="op">&amp;&amp;);</span> <span class="co">// move assignment</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>A<span class="op">();</span> <span class="co">// destructor</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>Порождающие операторы: конструкторы, присваивания, деструктор</li>
<li>Деструктор почти всегда генерируется сам, его перегрузка ни на что не влияет</li>
<li>Перегрузка move-конструктора или move-присваивания затрагивает все операции</li>
<li>Перегрузка конструктора копирования или присваивания не затрагивает move-операции</li>
<li><code class="sourceCode cpp"><span class="kw">delete</span></code> — явное удаление порождающего оператора</li>
<li><code class="sourceCode cpp"><span class="cf">default</span></code> — попросить компилятор сгенерировать порождающий оператор</li>
<li>Явное правило вывода конструктора: <code class="sourceCode cpp"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> myclass<span class="op">(</span>T<span class="op">&amp;&amp;,</span> <span class="dt">int</span><span class="op">)</span> <span class="op">-&gt;</span> myclass<span class="op">&lt;</span>T<span class="op">&gt;;</span></code></li>
</ul>
</div>
<div id="о-шаблонах" class="slide section level2">
<h1>О шаблонах</h1>
<ul>
<li><p><code class="sourceCode cpp"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span> <span class="kw">class</span> myclass<span class="op">;</span></code> — пакет шаблонных параметров</p></li>
<li><p><code class="sourceCode cpp"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">constexpr</span> T pi <span class="op">=</span> T<span class="op">(</span><span class="fl">3.1415926535897932385</span><span class="bu">L</span><span class="op">);</span></code> — шаблонная переменная</p></li>
<li><p><code class="sourceCode cpp"><span class="dt">size_t</span> N <span class="op">=</span> <span class="kw">sizeof</span><span class="op">...(</span>Ts<span class="op">);</span></code></p></li>
<li><p>Хранение аргументов в кортеже</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> abc <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    abc<span class="op">(</span>Ts<span class="op">...</span> ts<span class="op">):</span> x<span class="op">(</span>ts<span class="op">...)</span> <span class="op">{}</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;</span> x<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
</div>
<div id="распаковка-кортежа-в-аргументы" class="slide section level2">
<h1>Распаковка кортежа в аргументы</h1>
<ul>
<li><p>Использование <code class="sourceCode cpp"><span class="bu">std::</span>integer_sequence</code></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> func1<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;&amp;</span> t<span class="op">)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    func_impl<span class="op">(</span>t<span class="op">,</span> <span class="bu">std::</span>make_sequence_for<span class="op">&lt;</span>Ts<span class="op">...&gt;{});</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Tuple<span class="op">&gt;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> func2<span class="op">(</span><span class="at">const</span> Tuple<span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    func_impl<span class="op">(</span>t<span class="op">,</span> <span class="bu">std::</span>make_index_sequence<span class="op">&lt;</span><span class="bu">std::</span>tuple_size_v<span class="op">&lt;</span>Tuple<span class="op">&gt;&gt;{});</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Tuple<span class="op">,</span> <span class="dt">size_t</span><span class="op">...</span> Is<span class="op">&gt;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> func_impl<span class="op">(</span><span class="at">const</span> Tuple<span class="op">&amp;</span> t<span class="op">,</span> <span class="bu">std::</span>index_sequence<span class="op">&lt;</span>Is<span class="op">...&gt;)</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="op">...</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>get<span class="op">&lt;</span>Is<span class="op">&gt;(</span>t<span class="op">));</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;&amp;</span> t<span class="op">)</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>apply<span class="op">([&amp;</span>os<span class="op">](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;...</span> xs<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>os <span class="op">&lt;&lt;</span> <span class="op">...</span> <span class="op">&lt;&lt;</span> xs<span class="op">);</span> <span class="op">},</span> t<span class="op">);</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
</div>
<div id="операции-над-шаблонными-пакетами" class="slide section level2">
<h1>Операции над шаблонными пакетами</h1>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> bases<span class="op">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> X <span class="op">:</span> bases<span class="op">...</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> X<span class="op">::</span>bases<span class="op">::</span>g<span class="op">...;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>X<span class="op">&lt;</span>B<span class="op">,</span> D<span class="op">&gt;</span> x<span class="op">;</span></span></code></pre></div>
<p>Свёртки (наличие скобок важно)</p>
<ul>
<li><code class="sourceCode cpp"><span class="op">(</span> pack op <span class="op">...</span> <span class="op">)</span></code> — свёртка слева</li>
<li><code class="sourceCode cpp"><span class="op">(</span> pack op <span class="op">...</span> op init <span class="op">)</span></code> — свёртка слева с начальным значением</li>
<li><code class="sourceCode cpp"><span class="op">(</span> <span class="op">...</span> op pack <span class="op">)</span></code> — свёртка справа</li>
<li><code class="sourceCode cpp"><span class="op">(</span> init op <span class="op">...</span> op pack <span class="op">)</span></code> — свёртка справа с начальным значением</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> push_back_vec<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> v<span class="op">,</span> Args<span class="op">&amp;&amp;...</span> args<span class="op">)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>v<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>Args<span class="op">&gt;(</span>args<span class="op">)),</span> <span class="op">...);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div id="о-лямбда-выражениях" class="slide section level2">
<h1>О лямбда-выражениях</h1>
<p><code class="sourceCode cpp"><span class="kw">auto</span> f <span class="op">=</span> <span class="op">[</span>a <span class="op">=</span> <span class="dv">77</span><span class="op">,</span> <span class="op">&amp;</span>b<span class="op">](</span><span class="kw">auto</span> x<span class="op">)</span> <span class="at">mutable</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span> b <span class="op">=</span> x <span class="op">-</span> <span class="dv">78</span><span class="op">;</span> <span class="cf">return</span> a<span class="op">++;</span> <span class="op">}</span></code></p>
<ul>
<li><p>Лямбда-выражения == функторы</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> functor</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    functor<span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> b<span class="op">):</span> <span class="va">a_</span><span class="op">(</span><span class="dv">77</span><span class="op">),</span> <span class="va">b_</span><span class="op">(</span>b<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> x<span class="op">)</span> <span class="at">const</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">b_</span> <span class="op">=</span> x <span class="op">-</span> <span class="dv">78</span><span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">a_</span><span class="op">++;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">mutable</span> <span class="dt">int</span> <span class="va">a_</span><span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> <span class="at">const</span> <span class="va">b_</span><span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> f<span class="op">;</span></span></code></pre></div></li>
<li><p>Невозможно узнать тип лямбда-выражений, т.е. <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">(</span>lambda<span class="op">)</span> s <span class="op">=</span> <span class="op">...</span></code> не работает</p></li>
<li><p>Чтобы лямбды были полностью объектами, надо заворачивать их в объект <code class="sourceCode cpp"><span class="bu">std::</span>function</code></p></li>
<li><p>Результат лямбды можно не писать, он будет выведен сам (кроме ссылок)</p></li>
</ul>
</div>

<div id="следующие-стандарты" class="title-slide slide section level1">
<h1>Следующие стандарты</h1>

</div>
<div id="концепты-и-ограничители" class="slide section level2">
<h1>Концепты и ограничители</h1>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// концепт</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> EqualityComparable <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> a <span class="op">==</span> b <span class="op">}</span> <span class="op">-&gt;</span> <span class="dt">bool</span><span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">// ограничитель: T должен обладать оператором ==</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>EqualityComparable T<span class="op">&gt;</span> <span class="dt">void</span> f<span class="op">(</span>T<span class="op">&amp;&amp;);</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">// или</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">requires</span> EqualityComparable<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="dt">void</span> f<span class="op">(</span>T<span class="op">&amp;&amp;);</span></span></code></pre></div>
<ul>
<li>Компактнее вывод об ошибке (с концептами — 2 строки, без них — 50+)</li>
<li>По сигнатуре можно понять, какой тип данных ожидает функция</li>
<li>Ещё один способ ужесточения типизации</li>
</ul>
</div>
<div id="новое-в-stl" class="slide section level2">
<h1>Новое в STL</h1>
<ul>
<li><code class="sourceCode cpp"><span class="bu">std::</span>bit_cast</code> — замена <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code></li>
<li>Стандартные концепты (Integral, Assignable, Constructible, …)</li>
<li>Шаблонный тип может быть классом <code class="sourceCode cpp"><span class="kw">template</span><span class="op">&lt;</span>X x<span class="op">&gt;</span> <span class="dt">void</span> func<span class="op">()</span></code> (есть ограничения, например, <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code>)</li>
<li><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> — один оператор покрывает все отношения порядка и равенства (spaceship)</li>
<li>Все новые особенности языка можно проверить с помощью препроцессорных констант
<ul>
<li>например, <code class="sourceCode cpp">__cpp_lib_byte</code> говорит о наличии <code class="sourceCode cpp"><span class="bu">std::</span>byte</code></li>
</ul></li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>span</code> — декоратор над непрерывной областью памяти</li>
<li>Ranges — поддержка концепции диапазонов из <code>boost::range</code></li>
<li><code class="sourceCode cpp"><span class="bu">std::</span>is_detected</code> — детектирование наличия метода/оператора класса</li>
</ul>
</div>
</body>
</html>
